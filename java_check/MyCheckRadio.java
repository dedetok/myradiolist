/*
 * some code fix and or generated by chatgpt with manual checked and run 
 */


import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author dedetok
 * MAIN CLASS
 * change to match your requirements
 */
public class MyCheckRadio {
    static GithubRepository myGithub = new GithubRepository();
    
    public static void main(String[] args) {
        long start = System.currentTimeMillis(); // start
        
        System.out.println("Hello world");
        
        String sFileName = "myradio_radiolist.csv";
        String sFileOutput = "myradio_radiolist_output.csv";
        try {
            System.out.println("Version: "+myGithub.getListRadioVersion());
            ArrayList<RadioListItem> myListRadio = myGithub.getListRadioCsvFromFile(sFileName);
            
            System.out.println("processing "+myListRadio.size());
            ExecutorService myExecutor = Executors.newFixedThreadPool(5); // Adjust the pool size as needed
            List<Future<RadioListItem>> futures = new ArrayList<>();
        
            for (RadioListItem myItem : myListRadio) {
                Callable<RadioListItem> myCall = new CallableCheckUrlItem(myItem);

                // Submit the Callable to the executor and store the Future
                Future<RadioListItem> future = myExecutor.submit(myCall);
                futures.add(future);
            }
            

            System.out.println("printing "+futures.size());
            
            // Retrieve results
            /*
            for (Future<RadioListItem> future : futures) {
                try {
                    RadioListItem resultItem = future.get(); // This will block until the result is available
                    System.out.println(resultItem.mIcon+" status: " + resultItem.mIconStatus); // Handle the result as needed
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace(); // Handle exceptions
                }
            }
            
            // debug use 4 only
            for (int i=0;i<4;i++) {
                try {
                    RadioListItem tmpRadioItem = futures.get(i).get();; // Handle exceptions
                    System.out.println(tmpRadioItem.mIcon+" status: " + tmpRadioItem.mIconStatus + " " +tmpRadioItem.mStreamStatus); // Handle the result as needed
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace(); // Handle exceptions
                }
            }
            
*/
            
            // Shut down the executor service gracefully
            myExecutor.shutdown();
            
            myGithub.saveCSV(sFileOutput, futures);
            System.out.println("End");
            
        } catch (IOException ex) {
            System.out.println(ex);
        } catch (ParseException ex) {
            System.out.println(ex);
        }
        long end = System.currentTimeMillis(); // end
        long duration = end - start;  // milliseconds
        long seconds = duration / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;

        seconds %= 60;
        minutes %= 60;

        System.out.printf("Time taken: %02d:%02d:%02d%n", hours, minutes, seconds);
    }
}
