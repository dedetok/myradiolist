/*
 * some code fix and or generated by chatgpt with manual checked and run 
 */
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.Future;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.csv.QuoteMode;


/**
 *
 * @author dedetok
 */
public class GithubRepository {
    String myradiolistVersionURL = "https://raw.githubusercontent.com/dedetok/myradiolist/main/myradiolistversion.txt";
    String myradioListUrlCsv = "https://raw.githubusercontent.com/dedetok/myradiolist/refs/heads/main/myradio_radiolist.csv";

    private final String DATE_TIME_FORMAT = "yyyyMMdd HH:mm";
    SimpleDateFormat myDateFormat = new SimpleDateFormat(DATE_TIME_FORMAT, Locale.US);
    
    // Prepare CSV format (semicolon-delimited)
    CSVFormat myCSVFormat = CSVFormat.DEFAULT
        .withDelimiter(';')                     // Set separator as semicolon
        .withQuote('"')                         // Specify string quotes
        .withQuoteMode(QuoteMode.ALL)      // ⬅ FORCE quotes        
        .withFirstRecordAsHeader()              // Use the first row as header
        .withIgnoreSurroundingSpaces()          // Ignore spaces around fields
        .withTrim(); 
    
    /*
     * get version list radio
     * return String yyyy-mm-dd hh:mm:ss
     */
    public String getListRadioVersion() throws IOException, ParseException {
        URL url = new URL(myradiolistVersionURL);
        InputStreamReader isr = new InputStreamReader(url.openStream());
        String line=null;
        BufferedReader reader = new BufferedReader(isr);
        line = reader.readLine();
        // check format, if error it wil throw exception with reaching return value
        myDateFormat.parse(line);
        //Log.v("dedetok", "GithubRepositorygetradioversion "+line); // debug
        return line;
    }

    /*
     * get list radio in csv
     * may take big data to retrieve
     * return ArrayList<RadioListItem>
     */
    public ArrayList<RadioListItem> getListRadioCsv() throws IOException, MalformedURLException {
        ArrayList<RadioListItem> myRadioList = new ArrayList<>();
        URL myUrl = new URL(myradioListUrlCsv);
        HttpURLConnection connection = (HttpURLConnection) myUrl.openConnection();
        connection.setRequestMethod("GET");
        // Check response
        int status = connection.getResponseCode();
        if (status == 200) {
            
            //InputStreamReader reader = new InputStreamReader(myUrl.openStream(), StandardCharsets.UTF_8);
            BufferedReader br = new BufferedReader(new InputStreamReader(myUrl.openStream(), StandardCharsets.UTF_8));
            
            //CSVParser parser = new CSVParser(reader, format);
            CSVParser parser = new CSVParser(br, myCSVFormat);
            for (CSVRecord record : parser) {
                RadioListItem listItem  = new RadioListItem();
                listItem.mCountry = record.get("country");   // 0
                listItem.mCity = record.get("city");      // 1
                listItem.mRadio = record.get("radioname");     // 2
                listItem.mIcon = record.get("url_logo");      // 3
                listItem.mStreamURL = record.get("url_stream"); // 4
                myRadioList.add(listItem);
            }
        }
        return myRadioList;
    }
    
    /*
     * get list radio in csv
     * may take big data to retrieve
     * return ArrayList<RadioListItem>
     */
    public ArrayList<RadioListItem> getListRadioCsvFromFile(String fName) throws FileNotFoundException, IOException  {
        ArrayList<RadioListItem> myRadioList = new ArrayList<>();

        File myFile = new File(fName);
        BufferedReader br = new BufferedReader(new FileReader(myFile));
        CSVParser parser = new CSVParser(br, myCSVFormat);
        for (CSVRecord record : parser) {
            RadioListItem listItem  = new RadioListItem();
            listItem.mCountry = record.get("country");   // 0
            listItem.mCity = record.get("city");      // 1
            listItem.mRadio = record.get("radioname");     // 2
            listItem.mIcon = record.get("url_logo");      // 3
            listItem.mStreamURL = record.get("url_stream"); // 4
            myRadioList.add(listItem);
        }
        return myRadioList;
    }
    
    /**
     *
     * @param fileName
     * @param futures
     */
    public void saveCSV(String fileName, List<Future<RadioListItem>> futures) {
        try (
            BufferedWriter writer = Files.newBufferedWriter(Paths.get(fileName));
            CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT
                .withDelimiter(';')
                .withQuote('"')
                .withQuoteMode(QuoteMode.ALL)      // ⬅ FORCE quotes        
                .withHeader("country", "city", "radio", "icon", "streamurl", "iconstatus", "streamstatus")
            )
        ) {
            for (Future<RadioListItem> future : futures) {

                // block until executor finishes
                RadioListItem item = future.get();

                csvPrinter.printRecord(
                        item.mCountry,
                        item.mCity,
                        item.mRadio,
                        item.mIcon,
                        item.mStreamURL,
                        item.mIconStatus,
                        item.mStreamStatus
                );
            }

            csvPrinter.flush(); // make sure data is written

        } catch (Exception e) {
            e.printStackTrace();
        }
    }    
}
